from fastapi import Body
from sse_starlette.sse import EventSourceResponse
from configs import LLM_MODELS, TEMPERATURE
from server.utils import wrap_done, get_OpenAI
from langchain.chains import LLMChain
from langchain.callbacks import AsyncIteratorCallbackHandler
from typing import AsyncIterable, Optional
import asyncio
from langchain.prompts import PromptTemplate

from server.utils import get_prompt_template


async def completion(query: str = Body(..., description="User input", examples=["Annoyed and angry"]),
                     stream: bool = Body(False, description="Streaming output"),
                     echo: bool = Body(False, description="In addition to the output, the input is echoed"),
                     model_name: str = Body(LLM_MODELS[0], description="LLM model name. "),
                     temperature: float = Body(TEMPERATURE, description="LLM sample temperature", ge=0.0, le=1.0),
                     max_tokens: Optional[int] = Body(1024, description="Limit the number of tokens generated by LLM, default None represents the maximum value of the model"),
                     # top_p: float = Body(TOP_P, description="LLM kernel sampling. Do not set at the same time as temperature", gt=0.0, lt=1.0),
                     prompt_name: str = Body("default",
                                             description="Name of the prompt template used (configured in configs/prompt_config.py)"),
                     ):

    #todo Since ApiModelWorker is processed by chat by default, params["prompt"] will be parsed into messages, so ApiModelWorker needs to be processed accordingly
    async def completion_iterator(query: str,
                                  model_name: str = LLM_MODELS[0],
                                  prompt_name: str = prompt_name,
                                  echo: bool = echo,
                                  ) -> AsyncIterable[str]:
        nonlocal max_tokens
        callback = AsyncIteratorCallbackHandler()
        if isinstance(max_tokens, int) and max_tokens <= 0:
            max_tokens = None

        model = get_OpenAI(
            model_name=model_name,
            temperature=temperature,
            max_tokens=max_tokens,
            callbacks=[callback],
            echo=echo
        )

        prompt_template = get_prompt_template("completion", prompt_name)
        prompt = PromptTemplate.from_template(prompt_template)
        chain = LLMChain(prompt=prompt, llm=model)

        # Begin a task that runs in the background.
        task = asyncio.create_task(wrap_done(
            chain.acall({"input": query}),
            callback.done),
        )

        if stream:
            async for token in callback.aiter():
                # Use server-sent-events to stream the response
                yield token
        else:
            answer = ""
            async for token in callback.aiter():
                answer += token
            yield answer

        await task

    return EventSourceResponse(completion_iterator(query=query,
                                                 model_name=model_name,
                                                 prompt_name=prompt_name),
                             )
